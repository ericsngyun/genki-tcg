// Genki TCG Database Schema
// PostgreSQL via Prisma ORM

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// Organization & Users
// ============================================================================

model Organization {
  id             String  @id @default(cuid())
  name           String
  slug           String  @unique
  inviteCode     String  @unique
  logoUrl        String?
  primaryColor   String? @default("#4F46E5") // Indigo-600
  secondaryColor String? @default("#10B981") // Emerald-500

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  memberships     OrgMembership[]
  events          Event[]
  creditEntries   CreditLedgerEntry[]
  auditLogs       AuditLog[]
  seasons         Season[]
  lifetimeRatings PlayerCategoryLifetimeRating[]
  seasonalRatings PlayerCategorySeasonRating[]

  @@index([slug])
  @@index([inviteCode])
}

model User {
  id           String  @id @default(cuid())
  email        String  @unique
  name         String
  passwordHash String?
  avatarUrl    String?

  // Discord OAuth
  discordId       String? @unique
  discordUsername String?
  discordAvatar   String?

  // Email verification
  emailVerified   Boolean   @default(false)
  emailVerifiedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  memberships                     OrgMembership[]
  creditEntries                   CreditLedgerEntry[]            @relation("CreditLedgerUser")
  creditEntriesCreated            CreditLedgerEntry[]            @relation("CreditLedgerCreator")
  creditBalances                  CreditBalance[]
  entries                         Entry[]
  decklists                       Decklist[]
  matchesAsPlayerA                Match[]                        @relation("MatchPlayerA")
  matchesAsPlayerB                Match[]                        @relation("MatchPlayerB")
  notificationTokens              NotificationToken[]
  notifications                   Notification[]
  notificationPreferences         UserNotificationPreference[]
  auditLogs                       AuditLog[]                     @relation("AuditPerformer")
  refreshTokens                   RefreshToken[]
  passwordResetTokens             PasswordResetToken[]
  emailVerificationTokens         EmailVerificationToken[]
  lifetimeRatings                 PlayerCategoryLifetimeRating[]
  seasonalRatings                 PlayerCategorySeasonRating[]
  lifetimeRatingHistory           LifetimeRatingHistory[]
  lifetimeRatingHistoryAsOpponent LifetimeRatingHistory[]        @relation("LifetimeRatingHistoryOpponent")

  @@index([email])
}

enum OrgRole {
  OWNER
  STAFF
  PLAYER
}

model OrgMembership {
  id     String  @id @default(cuid())
  userId String
  orgId  String
  role   OrgRole @default(PLAYER)

  joinedAt DateTime @default(now())

  // Relations
  user User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  org  Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([userId, orgId])
  @@index([userId])
  @@index([orgId])
  @@index([orgId, role])
}

// ============================================================================
// Authentication & Security
// ============================================================================

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime

  // Device information for session management
  deviceName String?
  deviceType String? // "mobile", "web", "desktop"
  ipAddress  String?
  userAgent  String?

  createdAt  DateTime  @default(now())
  lastUsedAt DateTime  @default(now())
  revokedAt  DateTime?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

model PasswordResetToken {
  id        String    @id @default(cuid())
  userId    String
  token     String    @unique
  expiresAt DateTime
  usedAt    DateTime?

  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

model EmailVerificationToken {
  id        String    @id @default(cuid())
  userId    String
  token     String    @unique
  expiresAt DateTime
  usedAt    DateTime?

  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

// ============================================================================
// Credits System
// ============================================================================

enum CreditReasonCode {
  PRIZE
  REFUND
  PURCHASE
  MANUAL_ADD
  MANUAL_DEDUCT
  EVENT_ENTRY
  EVENT_REFUND
  PROMO // Promotional credits (welcome bonus, campaigns, etc.)
}

model CreditLedgerEntry {
  id         String           @id @default(cuid())
  orgId      String
  userId     String
  amount     Int // Signed: positive = credit, negative = debit
  reasonCode CreditReasonCode
  memo       String?

  relatedEventId String?
  createdBy      String // User ID of staff/owner

  createdAt DateTime @default(now())

  // Relations
  org           Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade, name: "CreditLedgerUser")
  createdByUser User         @relation(fields: [createdBy], references: [id], onDelete: Cascade, name: "CreditLedgerCreator")
  event         Event?       @relation(fields: [relatedEventId], references: [id], onDelete: SetNull)

  @@index([orgId, userId])
  @@index([userId, createdAt(sort: Desc)])
  @@index([createdBy])
  @@index([createdAt(sort: Desc)])
}

// Derived balance table for performance
model CreditBalance {
  id      String @id @default(cuid())
  orgId   String
  userId  String
  balance Int    @default(0)

  lastTransactionAt DateTime?
  updatedAt         DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([orgId, userId])
  @@index([userId])
  @@index([orgId, balance])
}

// ============================================================================
// Events & Tournaments
// ============================================================================

enum GameType {
  ONE_PIECE_TCG
  AZUKI_TCG
  RIFTBOUND
}

enum EventFormat {
  STANDARD
  DRAFT
  SEALED
  CONSTRUCTED
  SUPER_PRE_RELEASE
  PRE_RELEASE
}

enum EventStatus {
  DRAFT
  SCHEDULED
  REGISTRATION_CLOSED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model Event {
  id          String      @id @default(cuid())
  orgId       String
  name        String
  game        GameType
  format      EventFormat
  status      EventStatus @default(DRAFT)
  description String?

  startAt       DateTime
  endAt         DateTime?
  maxPlayers    Int?
  entryFeeCents Int?      @default(0)

  requiresDecklist      Boolean @default(false)
  allowLateRegistration Boolean @default(true)

  roundsPlanned Int?
  currentRound  Int? @default(0)

  // Prize distribution
  totalPrizeCredits   Int?      @default(0)
  prizesDistributed   Boolean   @default(false)
  prizesDistributedAt DateTime?
  prizesDistributedBy String?

  // Rating processing
  ratingsProcessed   Boolean   @default(false)
  ratingsProcessedAt DateTime?
  ratingsProcessedBy String?

  // Season link (auto-assigned based on startAt date)
  seasonId String?

  createdBy String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  org                     Organization             @relation(fields: [orgId], references: [id], onDelete: Cascade)
  season                  Season?                  @relation(fields: [seasonId], references: [id], onDelete: SetNull)
  entries                 Entry[]
  rounds                  Round[]
  standingSnapshots       StandingSnapshot[]
  creditEntries           CreditLedgerEntry[]
  lifetimeRatingHistory   LifetimeRatingHistory[]
  tournamentRatingUpdates TournamentRatingUpdate[]

  @@index([orgId, status])
  @@index([orgId, startAt])
  @@index([status])
  @@index([seasonId])
  @@index([orgId, seasonId, status])
}

// ============================================================================
// Entries & Decklists
// ============================================================================

model Entry {
  id      String @id @default(cuid())
  eventId String
  userId  String

  registeredAt      DateTime  @default(now())
  checkedInAt       DateTime?
  droppedAt         DateTime?
  droppedAfterRound Int?
  joinedAtRound     Int? // For late additions: which round they joined (receives phantom losses for earlier rounds)

  // Payment tracking
  paidAt     DateTime?
  paidAmount Int? // Amount paid in cents
  paidBy     String? // Staff user ID who confirmed payment

  // Final standings
  placement Int? // Final placement (1 = 1st place, 2 = 2nd, etc.)

  decklistId String?

  // Relations
  event    Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  decklist Decklist?

  @@unique([eventId, userId])
  @@index([eventId, checkedInAt])
  @@index([eventId, paidAt])
  @@index([userId])
}

model Decklist {
  id      String @id @default(cuid())
  entryId String @unique
  userId  String

  deckName     String?
  mainDeckUrl  String?
  mainDeckJson Json?

  lockedAt  DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relations
  entry Entry @relation(fields: [entryId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// ============================================================================
// Rounds & Matches
// ============================================================================

enum RoundStatus {
  PENDING
  ACTIVE
  COMPLETED
  CANCELLED
}

model Round {
  id          String      @id @default(cuid())
  eventId     String
  roundNumber Int
  status      RoundStatus @default(PENDING)

  startAt      DateTime?
  endAt        DateTime?
  timerSeconds Int?      @default(3000) // 50 minutes default

  // Audit trail for pairings
  pairingsCreatedBy     String? // Staff user ID who created pairings
  pairingsCreatedAt     DateTime? // When pairings were created
  pairingsRegeneratedBy String? // Staff user ID who regenerated pairings (if any)
  pairingsRegeneratedAt DateTime? // When pairings were regenerated (if any)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  event   Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  matches Match[]

  @@unique([eventId, roundNumber])
  @@index([eventId, status])
}

enum MatchResult {
  PLAYER_A_WIN
  PLAYER_B_WIN
  DRAW
  INTENTIONAL_DRAW
  DOUBLE_LOSS
  PLAYER_A_DQ
  PLAYER_B_DQ
}

model Match {
  id          String @id @default(cuid())
  roundId     String
  tableNumber Int

  playerAId String
  playerBId String? // Null for bye

  result    MatchResult?
  gamesWonA Int?         @default(0)
  gamesWonB Int?         @default(0)

  reportedBy  String? // User ID
  confirmedBy String? // User ID (for player self-report)
  reportedAt  DateTime?

  overriddenBy String? // Staff user ID
  overriddenAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  round                 Round                   @relation(fields: [roundId], references: [id], onDelete: Cascade)
  playerA               User                    @relation("MatchPlayerA", fields: [playerAId], references: [id], onDelete: Cascade)
  playerB               User?                   @relation("MatchPlayerB", fields: [playerBId], references: [id], onDelete: Cascade)
  lifetimeRatingHistory LifetimeRatingHistory[]

  @@unique([roundId, tableNumber])
  @@index([roundId])
  @@index([playerAId])
  @@index([playerBId])
}

// ============================================================================
// Standings Snapshots
// ============================================================================

model StandingSnapshot {
  id          String @id @default(cuid())
  eventId     String
  roundNumber Int

  // JSON array of PlayerStanding objects
  standings Json

  createdAt DateTime @default(now())

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, roundNumber])
  @@index([eventId])
}

// ============================================================================
// Notifications
// ============================================================================

enum NotificationPlatform {
  IOS
  ANDROID
  WEB
}

enum NotificationType {
  EVENT_PUBLISHED
  EVENT_STARTING_SOON
  PAIRINGS_POSTED
  ROUND_STARTED
  MATCH_RESULT_CONFIRMED
  TOURNAMENT_COMPLETED
  PRIZES_DISTRIBUTED
  EVENT_CANCELLED
  EVENT_UPDATED
  MATCH_RESULT_REPORTED
  PLAYER_REGISTERED
  ALL_PLAYERS_CHECKED_IN
  MATCH_DISPUTED
  ROUND_COMPLETION_READY
  PLAYER_DROPPED
  SYSTEM_ERROR
}

enum NotificationStatus {
  UNREAD
  READ
  ARCHIVED
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

model NotificationToken {
  id       String               @id @default(cuid())
  userId   String
  platform NotificationPlatform
  token    String               @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, platform, token])
  @@index([userId])
}

model Notification {
  id     String @id @default(cuid())
  userId String
  orgId  String

  type     NotificationType
  status   NotificationStatus   @default(UNREAD)
  priority NotificationPriority @default(NORMAL)

  title String
  body  String
  data  Json?

  // Optional links to related entities
  eventId String?
  matchId String?
  roundId String?

  // Delivery tracking
  sentViaWebSocket Boolean   @default(false)
  sentViaPush      Boolean   @default(false)
  pushSentAt       DateTime?

  readAt    DateTime?
  createdAt DateTime  @default(now())
  expiresAt DateTime // Auto-delete after 30 days

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status, createdAt(sort: Desc)])
  @@index([userId, orgId, status])
  @@index([expiresAt])
  @@index([type, status])
}

model UserNotificationPreference {
  id     String @id @default(cuid())
  userId String
  orgId  String

  notificationType NotificationType

  enableInApp Boolean @default(true)
  enablePush  Boolean @default(true)
  enableEmail Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, orgId, notificationType])
  @@index([userId, orgId])
}

// ============================================================================
// OAuth State (CSRF Protection)
// ============================================================================

model OAuthState {
  id          String   @id @default(cuid())
  state       String   @unique
  redirectUri String
  expiresAt   DateTime
  createdAt   DateTime @default(now())

  @@index([state])
  @@index([expiresAt])
}

// ============================================================================
// Audit Log
// ============================================================================

enum AuditAction {
  CREDIT_ADJUST
  MATCH_OVERRIDE
  ROUND_REPAIR
  BYE_ASSIGN
  PLAYER_DROP
  PLAYER_LATE_ADD
  EVENT_CANCEL
  DECKLIST_LOCK
  RESULT_OVERRIDE
}

model AuditLog {
  id          String      @id @default(cuid())
  orgId       String
  action      AuditAction
  performedBy String // User ID

  targetUserId  String?
  targetEventId String?
  targetMatchId String?

  // JSON metadata for additional context
  metadata Json?

  createdAt DateTime @default(now())

  // Relations
  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  performer User         @relation("AuditPerformer", fields: [performedBy], references: [id], onDelete: Cascade)

  @@index([orgId, createdAt(sort: Desc)])
  @@index([orgId, action, createdAt(sort: Desc)])
  @@index([performedBy])
  @@index([targetEventId])
}

// ============================================================================
// Seasons (Quarterly periods for rating resets and prizes)
// ============================================================================

enum SeasonStatus {
  UPCOMING
  ACTIVE
  COMPLETED
}

model Season {
  id        String       @id @default(cuid())
  orgId     String
  name      String // e.g., "2025 Q1", "2025 Q2"
  startDate DateTime
  endDate   DateTime
  status    SeasonStatus @default(UPCOMING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  org                     Organization                 @relation(fields: [orgId], references: [id], onDelete: Cascade)
  events                  Event[]
  seasonalRatings         PlayerCategorySeasonRating[]
  tournamentRatingUpdates TournamentRatingUpdate[]

  @@index([orgId, status])
  @@index([orgId, startDate])
  @@index([orgId, status, startDate])
}

// ============================================================================
// Player Rating & Leaderboard System (Glicko-2)
// Lifetime ratings: Never reset, used for baseline stability
// Seasonal ratings: Reset each season, used for tiers and prizes
// ============================================================================

// Lifetime rating per category (never resets, baseline for new seasons)
model PlayerCategoryLifetimeRating {
  id       String   @id @default(cuid())
  userId   String
  orgId    String
  category GameType // ONE_PIECE_TCG, AZUKI_TCG, RIFTBOUND

  // Glicko-2 components (lifetime, never reset)
  rating          Float @default(1500)
  ratingDeviation Float @default(350)
  volatility      Float @default(0.06)

  // Lifetime statistics
  totalRatedMatches Int @default(0)
  matchWins         Int @default(0)
  matchLosses       Int @default(0)
  matchDraws        Int @default(0)

  // Metadata
  lastUpdatedAt DateTime  @default(now())
  lastMatchAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user    User                    @relation(fields: [userId], references: [id], onDelete: Cascade)
  org     Organization            @relation(fields: [orgId], references: [id], onDelete: Cascade)
  history LifetimeRatingHistory[]

  @@unique([userId, orgId, category])
  @@index([userId])
  @@index([orgId, category, rating(sort: Desc)]) // Lifetime leaderboard
  @@map("player_category_lifetime_rating")
}

// Seasonal rating per category (resets each season, determines tiers)
model PlayerCategorySeasonRating {
  id       String   @id @default(cuid())
  userId   String
  orgId    String
  seasonId String
  category GameType // ONE_PIECE_TCG, AZUKI_TCG, RIFTBOUND

  // Glicko-2 components (reset each season from lifetime rating)
  rating          Float @default(1500)
  ratingDeviation Float @default(350)
  volatility      Float @default(0.06)

  // Season statistics (this season only)
  totalRatedMatches Int @default(0)
  matchWins         Int @default(0)
  matchLosses       Int @default(0)
  matchDraws        Int @default(0)

  // Metadata
  lastUpdatedAt DateTime  @default(now())
  lastMatchAt   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user   User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  org    Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  season Season       @relation(fields: [seasonId], references: [id], onDelete: Cascade)

  @@unique([userId, orgId, seasonId, category])
  @@index([userId])
  @@index([seasonId, category, rating(sort: Desc)]) // Seasonal leaderboard
  @@index([orgId, seasonId, category])
  @@map("player_category_season_rating")
}

// Lifetime rating history (match-by-match changes to lifetime rating)
model LifetimeRatingHistory {
  id               String  @id @default(cuid())
  lifetimeRatingId String // PlayerCategoryLifetimeRating ID
  eventId          String?
  matchId          String?

  // Rating changes
  ratingBefore Float
  ratingAfter  Float
  ratingChange Float

  rdBefore Float // Rating deviation before
  rdAfter  Float // Rating deviation after

  volatilityBefore Float
  volatilityAfter  Float

  // Match context
  opponentId           String
  opponentRatingBefore Float
  matchResult          MatchResult

  calculatedAt DateTime @default(now())

  // Relations
  lifetimeRating PlayerCategoryLifetimeRating @relation(fields: [lifetimeRatingId], references: [id], onDelete: Cascade)
  event          Event?                       @relation(fields: [eventId], references: [id], onDelete: SetNull)
  match          Match?                       @relation(fields: [matchId], references: [id], onDelete: SetNull)
  opponent       User                         @relation("LifetimeRatingHistoryOpponent", fields: [opponentId], references: [id], onDelete: Cascade)
  User           User?                        @relation(fields: [userId], references: [id])
  userId         String?

  @@index([lifetimeRatingId, calculatedAt(sort: Desc)]) // Player history timeline
  @@index([eventId]) // Event-specific queries
  @@index([matchId]) // Match-specific queries
  @@map("lifetime_rating_history")
}

// Tournament rating update audit log (per player, per tournament)
model TournamentRatingUpdate {
  id           String   @id @default(cuid())
  tournamentId String // Event ID
  seasonId     String
  userId       String
  category     GameType

  // Lifetime rating changes  
  lifetimeRatingBefore Float
  lifetimeRatingAfter  Float
  lifetimeRatingDelta  Float

  // Seasonal rating changes
  seasonalRatingBefore Float
  seasonalRatingAfter  Float
  seasonalRatingDelta  Float

  // Tier changes (based on seasonal rating)
  tierBefore String // e.g., "GOLD"
  tierAfter  String // e.g., "PLATINUM"  
  tierChange String // "UP" | "DOWN" | "SAME"

  // Match count for this tournament
  matchesInTournament Int

  createdAt DateTime @default(now())

  // Relations
  tournament Event  @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  season     Season @relation(fields: [seasonId], references: [id], onDelete: Cascade)

  @@index([tournamentId])
  @@index([userId, seasonId, category])
  @@index([seasonId, category])
  @@map("tournament_rating_update")
}
