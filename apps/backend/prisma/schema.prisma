// Genki TCG Database Schema
// PostgreSQL via Prisma ORM

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// Organization & Users
// ============================================================================

model Organization {
  id             String  @id @default(cuid())
  name           String
  slug           String  @unique
  inviteCode     String  @unique
  logoUrl        String?
  primaryColor   String? @default("#4F46E5") // Indigo-600
  secondaryColor String? @default("#10B981") // Emerald-500

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  memberships   OrgMembership[]
  events        Event[]
  creditEntries CreditLedgerEntry[]
  auditLogs     AuditLog[]
  playerRatings PlayerRating[]

  @@index([slug])
  @@index([inviteCode])
}

model User {
  id           String  @id @default(cuid())
  email        String  @unique
  name         String
  passwordHash String?
  avatarUrl    String?

  // Discord OAuth
  discordId       String? @unique
  discordUsername String?
  discordAvatar   String?

  // Email verification
  emailVerified   Boolean   @default(false)
  emailVerifiedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  memberships              OrgMembership[]
  creditEntries            CreditLedgerEntry[]       @relation("CreditLedgerUser")
  creditEntriesCreated     CreditLedgerEntry[]       @relation("CreditLedgerCreator")
  creditBalances           CreditBalance[]
  entries                  Entry[]
  decklists                Decklist[]
  matchesAsPlayerA         Match[]                   @relation("MatchPlayerA")
  matchesAsPlayerB         Match[]                   @relation("MatchPlayerB")
  notificationTokens       NotificationToken[]
  notifications            Notification[]
  notificationPreferences  UserNotificationPreference[]
  auditLogs                AuditLog[]                @relation("AuditPerformer")
  refreshTokens            RefreshToken[]
  passwordResetTokens      PasswordResetToken[]
  emailVerificationTokens  EmailVerificationToken[]
  playerRatings            PlayerRating[]
  ratingHistoryAsOpponent  PlayerRatingHistory[]     @relation("RatingHistoryOpponent")

  @@index([email])
}

enum OrgRole {
  OWNER
  STAFF
  PLAYER
}

model OrgMembership {
  id     String  @id @default(cuid())
  userId String
  orgId  String
  role   OrgRole @default(PLAYER)

  joinedAt DateTime @default(now())

  // Relations
  user User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  org  Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)

  @@unique([userId, orgId])
  @@index([userId])
  @@index([orgId])
  @@index([orgId, role])
}

// ============================================================================
// Authentication & Security
// ============================================================================

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime

  // Device information for session management
  deviceName String?
  deviceType String? // "mobile", "web", "desktop"
  ipAddress  String?
  userAgent  String?

  createdAt  DateTime  @default(now())
  lastUsedAt DateTime  @default(now())
  revokedAt  DateTime?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

model PasswordResetToken {
  id        String    @id @default(cuid())
  userId    String
  token     String    @unique
  expiresAt DateTime
  usedAt    DateTime?

  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

model EmailVerificationToken {
  id        String    @id @default(cuid())
  userId    String
  token     String    @unique
  expiresAt DateTime
  usedAt    DateTime?

  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

// ============================================================================
// Credits System
// ============================================================================

enum CreditReasonCode {
  PRIZE
  REFUND
  PURCHASE
  MANUAL_ADD
  MANUAL_DEDUCT
  EVENT_ENTRY
  EVENT_REFUND
  PROMO          // Promotional credits (welcome bonus, campaigns, etc.)
}

model CreditLedgerEntry {
  id         String           @id @default(cuid())
  orgId      String
  userId     String
  amount     Int // Signed: positive = credit, negative = debit
  reasonCode CreditReasonCode
  memo       String?

  relatedEventId String?
  createdBy      String // User ID of staff/owner

  createdAt DateTime @default(now())

  // Relations
  org           Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade, name: "CreditLedgerUser")
  createdByUser User         @relation(fields: [createdBy], references: [id], onDelete: Cascade, name: "CreditLedgerCreator")
  event         Event?       @relation(fields: [relatedEventId], references: [id], onDelete: SetNull)

  @@index([orgId, userId])
  @@index([userId, createdAt(sort: Desc)])
  @@index([createdBy])
  @@index([createdAt(sort: Desc)])
}

// Derived balance table for performance
model CreditBalance {
  id      String @id @default(cuid())
  orgId   String
  userId  String
  balance Int    @default(0)

  lastTransactionAt DateTime?
  updatedAt         DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([orgId, userId])
  @@index([userId])
}

// ============================================================================
// Events & Tournaments
// ============================================================================

enum GameType {
  ONE_PIECE_TCG
  AZUKI_TCG
  RIFTBOUND
}

enum EventFormat {
  STANDARD
  DRAFT
  SEALED
  CONSTRUCTED
  SUPER_PRE_RELEASE
  PRE_RELEASE
}

enum EventStatus {
  DRAFT
  SCHEDULED
  REGISTRATION_CLOSED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

model Event {
  id          String      @id @default(cuid())
  orgId       String
  name        String
  game        GameType
  format      EventFormat
  status      EventStatus @default(DRAFT)
  description String?

  startAt       DateTime
  endAt         DateTime?
  maxPlayers    Int?
  entryFeeCents Int?      @default(0)

  requiresDecklist      Boolean @default(false)
  allowLateRegistration Boolean @default(true)

  roundsPlanned Int?
  currentRound  Int? @default(0)

  // Prize distribution
  totalPrizeCredits   Int?      @default(0)
  prizesDistributed   Boolean   @default(false)
  prizesDistributedAt DateTime?
  prizesDistributedBy String?

  createdBy String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  org               Organization        @relation(fields: [orgId], references: [id], onDelete: Cascade)
  entries           Entry[]
  rounds            Round[]
  standingSnapshots StandingSnapshot[]
  creditEntries     CreditLedgerEntry[]
  ratingHistory     PlayerRatingHistory[]

  @@index([orgId, status])
  @@index([orgId, startAt])
  @@index([status])
}

// ============================================================================
// Entries & Decklists
// ============================================================================

model Entry {
  id      String @id @default(cuid())
  eventId String
  userId  String

  registeredAt      DateTime  @default(now())
  checkedInAt       DateTime?
  droppedAt         DateTime?
  droppedAfterRound Int?

  // Payment tracking
  paidAt     DateTime?
  paidAmount Int? // Amount paid in cents
  paidBy     String? // Staff user ID who confirmed payment

  decklistId String?

  // Relations
  event    Event     @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  decklist Decklist?

  @@unique([eventId, userId])
  @@index([eventId, checkedInAt])
  @@index([eventId, paidAt])
  @@index([userId])
}

model Decklist {
  id      String @id @default(cuid())
  entryId String @unique
  userId  String

  deckName     String?
  mainDeckUrl  String?
  mainDeckJson Json?

  lockedAt  DateTime?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relations
  entry Entry @relation(fields: [entryId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

// ============================================================================
// Rounds & Matches
// ============================================================================

enum RoundStatus {
  PENDING
  ACTIVE
  COMPLETED
  CANCELLED
}

model Round {
  id          String      @id @default(cuid())
  eventId     String
  roundNumber Int
  status      RoundStatus @default(PENDING)

  startAt      DateTime?
  endAt        DateTime?
  timerSeconds Int?      @default(3000) // 50 minutes default

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  event   Event   @relation(fields: [eventId], references: [id], onDelete: Cascade)
  matches Match[]

  @@unique([eventId, roundNumber])
  @@index([eventId, status])
}

enum MatchResult {
  PLAYER_A_WIN
  PLAYER_B_WIN
  DRAW
  INTENTIONAL_DRAW
  DOUBLE_LOSS
  PLAYER_A_DQ
  PLAYER_B_DQ
}

model Match {
  id          String @id @default(cuid())
  roundId     String
  tableNumber Int

  playerAId String
  playerBId String? // Null for bye

  result    MatchResult?
  gamesWonA Int?         @default(0)
  gamesWonB Int?         @default(0)

  reportedBy  String? // User ID
  confirmedBy String? // User ID (for player self-report)
  reportedAt  DateTime?

  overriddenBy String? // Staff user ID
  overriddenAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  round         Round                 @relation(fields: [roundId], references: [id], onDelete: Cascade)
  playerA       User                  @relation("MatchPlayerA", fields: [playerAId], references: [id], onDelete: Cascade)
  playerB       User?                 @relation("MatchPlayerB", fields: [playerBId], references: [id], onDelete: Cascade)
  ratingHistory PlayerRatingHistory[]

  @@unique([roundId, tableNumber])
  @@index([roundId])
  @@index([playerAId])
  @@index([playerBId])
}

// ============================================================================
// Standings Snapshots
// ============================================================================

model StandingSnapshot {
  id          String @id @default(cuid())
  eventId     String
  roundNumber Int

  // JSON array of PlayerStanding objects
  standings Json

  createdAt DateTime @default(now())

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@unique([eventId, roundNumber])
  @@index([eventId])
}

// ============================================================================
// Notifications
// ============================================================================

enum NotificationPlatform {
  IOS
  ANDROID
  WEB
}

enum NotificationType {
  EVENT_PUBLISHED
  EVENT_STARTING_SOON
  PAIRINGS_POSTED
  ROUND_STARTED
  MATCH_RESULT_CONFIRMED
  TOURNAMENT_COMPLETED
  PRIZES_DISTRIBUTED
  EVENT_CANCELLED
  EVENT_UPDATED
  MATCH_RESULT_REPORTED
  PLAYER_REGISTERED
  ALL_PLAYERS_CHECKED_IN
  MATCH_DISPUTED
  ROUND_COMPLETION_READY
  PLAYER_DROPPED
  SYSTEM_ERROR
}

enum NotificationStatus {
  UNREAD
  READ
  ARCHIVED
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  URGENT
}

model NotificationToken {
  id       String               @id @default(cuid())
  userId   String
  platform NotificationPlatform
  token    String               @unique

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, platform, token])
  @@index([userId])
}

model Notification {
  id     String               @id @default(cuid())
  userId String
  orgId  String

  type     NotificationType
  status   NotificationStatus   @default(UNREAD)
  priority NotificationPriority @default(NORMAL)

  title String
  body  String
  data  Json?

  // Optional links to related entities
  eventId String?
  matchId String?
  roundId String?

  // Delivery tracking
  sentViaWebSocket Boolean   @default(false)
  sentViaPush      Boolean   @default(false)
  pushSentAt       DateTime?

  readAt    DateTime?
  createdAt DateTime  @default(now())
  expiresAt DateTime // Auto-delete after 30 days

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, status, createdAt(sort: Desc)])
  @@index([userId, orgId, status])
  @@index([expiresAt])
  @@index([type, status])
}

model UserNotificationPreference {
  id     String           @id @default(cuid())
  userId String
  orgId  String

  notificationType NotificationType

  enableInApp Boolean @default(true)
  enablePush  Boolean @default(true)
  enableEmail Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, orgId, notificationType])
  @@index([userId, orgId])
}

// ============================================================================
// OAuth State (CSRF Protection)
// ============================================================================

model OAuthState {
  id          String   @id @default(cuid())
  state       String   @unique
  redirectUri String
  expiresAt   DateTime
  createdAt   DateTime @default(now())

  @@index([state])
  @@index([expiresAt])
}

// ============================================================================
// Audit Log
// ============================================================================

enum AuditAction {
  CREDIT_ADJUST
  MATCH_OVERRIDE
  ROUND_REPAIR
  BYE_ASSIGN
  PLAYER_DROP
  PLAYER_LATE_ADD
  EVENT_CANCEL
  DECKLIST_LOCK
  RESULT_OVERRIDE
}

model AuditLog {
  id          String      @id @default(cuid())
  orgId       String
  action      AuditAction
  performedBy String // User ID

  targetUserId  String?
  targetEventId String?
  targetMatchId String?

  // JSON metadata for additional context
  metadata Json?

  createdAt DateTime @default(now())

  // Relations
  org       Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
  performer User         @relation("AuditPerformer", fields: [performedBy], references: [id], onDelete: Cascade)

  @@index([orgId, createdAt(sort: Desc)])
  @@index([performedBy])
  @@index([targetEventId])
}

// ============================================================================
// Player Rating & Leaderboard System (Glicko-2)
// ============================================================================

model PlayerRating {
  id       String   @id @default(cuid())
  userId   String
  orgId    String
  gameType GameType // Track rating per game system

  // Glicko-2 components
  rating          Float @default(1500) // Player's rating (higher = better)
  ratingDeviation Float @default(350) // Uncertainty/confidence (lower = more certain)
  volatility      Float @default(0.06) // Expected fluctuation (sigma)

  // Statistics
  matchesPlayed Int @default(0)
  matchWins     Int @default(0)
  matchLosses   Int @default(0)
  matchDraws    Int @default(0)

  // Metadata
  lastUpdatedAt DateTime  @default(now())
  lastMatchAt   DateTime?
  isProvisional Boolean   @default(true) // < 30 matches

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user    User                  @relation(fields: [userId], references: [id], onDelete: Cascade)
  org     Organization          @relation(fields: [orgId], references: [id], onDelete: Cascade)
  history PlayerRatingHistory[]

  @@unique([userId, orgId, gameType])
  @@index([userId])
  @@index([orgId, gameType, rating(sort: Desc)]) // Leaderboard queries
  @@index([orgId, gameType, isProvisional]) // Filter provisional players
}

model PlayerRatingHistory {
  id             String @id @default(cuid())
  playerRatingId String
  eventId        String?
  matchId        String?

  // Rating changes
  ratingBefore Float
  ratingAfter  Float
  ratingChange Float

  rdBefore Float // Rating deviation before
  rdAfter  Float // Rating deviation after

  volatilityBefore Float
  volatilityAfter  Float

  // Match context
  opponentId           String
  opponentRatingBefore Float
  matchResult          MatchResult

  calculatedAt DateTime @default(now())

  // Relations
  playerRating PlayerRating @relation(fields: [playerRatingId], references: [id], onDelete: Cascade)
  event        Event?       @relation(fields: [eventId], references: [id], onDelete: SetNull)
  match        Match?       @relation(fields: [matchId], references: [id], onDelete: SetNull)
  opponent     User         @relation("RatingHistoryOpponent", fields: [opponentId], references: [id], onDelete: Cascade)

  @@index([playerRatingId, calculatedAt(sort: Desc)]) // Player history timeline
  @@index([eventId]) // Event-specific queries
  @@index([matchId]) // Match-specific queries
}
